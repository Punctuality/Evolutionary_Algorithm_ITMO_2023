# Лабораторная работа №6

**Дисциплина:** "Эволюционные вычисления"

**Дата:** 29/03/2023

**Выполнил:** Федоров Сергей, M4150 

**Название:** "РАСПРЕДЕЛЕННЫЕ ЭВОЛЮЦИОННЫЕ АЛГОРИТМЫ"

**Репозиторий с исходным кодом:** [Репозиторий](https://github.com/Punctuality/Evolutionary_Algorithm_ITMO_2023)

## Описания выполнения:

1. Выбор языка, фреймворка и подхода к решению задачи
2. Настройка модуля прогона по сетке
3. Итоговые результаты работы алгоритма
4. Ответы на поставленные вопросы

## Выбор языка, фреймворка и подхода к решению задачи

Продолжая с прошлой лабораторной работы я выбрал язык `Scala`, так как:

1. Могу использовать библиотеку `Cats` удобной работы с отлодженными вычислениями
2. Система типов помогает не допускать дополнительных ошибок при разработке
3. Переиспользовать код для настройки и поиска по сетке из прошлой лабораторной работы

Также стоит заметить что, для проведения тестов я заменил стандартную виртуальную машину `JVM` на `GraalVM`, что по моим замерам дало прирост в производительности в 2-3.5 раза.

Посколько темплейт для лабораторной работы был предоставлен в виде `Java` проекта, то пришлось переписать все предоставленные примеры алгоритмов, а так же переписать реализацию `MultiFitnessFunction`, естественно без изменения функционала.

### Настройка модуля прогона по сетке
#### PerfExperimentSetup, PerfExperimentResult, PerfExperimentRunner

В данной лабораторной работе использовался все тот же самый модуль прогона по сетке, с только лишь измененными типами входных и выходных данных.

```scala
// PerfExperimentSetup.scala
final case class PerfExperimentSetup(
  dimension: Int,
  populationSize: Int,
  generations: Int,
  algoType: PerfExperimentSetup.AlgoType,
  complexity: Int
)

given Show[AlgoType] with
  def show(algoType: AlgoType): String = algoType match
    case AlgoType.SingleThreaded => "SingleThreaded"
    case AlgoType.MasterSlave => "MasterSlave"
    case AlgoType.Islands(islandCount, epochLength, migrationCount) => 
      s"Islands($islandCount)"
```

```scala
// PerfExperimentResult.scala
final case class PerfExperimentResult(
  bestResult: Double,
  bestCandidate: MyCandidate,
  firstAchievedIter: Int,
  finishedEvalAt: Int,
  evalTime: Long
) extends Ordered[PerfExperimentResult]:
  
  extension (prev: Int)
      private infix def ifZero(next: => Int): Int = 
        if prev == 0 then next else prev

  override def compare(that: PerfExperimentResult): Int = 
    this.bestResult.compare(that.bestResult) ifZero
      this.finishedEvalAt.compare(that.finishedEvalAt) ifZero
      this.firstAchievedIter.compare(that.firstAchievedIter) ifZero
      this.evalTime.compare(that.evalTime)
```

В отличие от предыдущих лабораторных работ, в данном случае нету предположения что прогон каждого эксперимента будет происходить в отдельном изолированном потоке (поскольку это не так), поэтому на данный раз, что различные эксперименты, что их повторы происходят в последовательном режиме без параллелизма, тем самым освобождая ресурсы для потоков исполнения самого алгоритма.

```scala
// OMMITTED

        // setting up algo here

        Iterator
          .range(0, repeats)
          .map(iter => runExperiment(algo(iter), setup))
          .toList

      .flatMap(_.sequence)

// OMMITTED
```

### Итоговые результаты работы алгоритма

В итоге был проведен прогон при разных параметрах размерности, кол-ва поколений, размера популяции и типа работы алгоритма (в одном потоке, master-slave и островной на 2 и 8 островов). Результаты усреднялись по 10 запускам. Таблица всех результатов в отчете не предоставленна, так как там 864 строки, однако она доступна в репозитории.

Результаты по таблице требуемой в методичке, приведены ниже:

| Dimension | PopulationSize | Generations | EngineType     | Complexity | Best result       | Mean best result | Mean eval ime |
| :-------- | :------------- | :---------- | :------------- | :--------- | :---------------- | :--------------- | :------------ |
| 10        | 50             | 1000        | SingleThreaded | 0          | 0.0               | 0.0              | 26.9          |
| 10        | 50             | 1000        | SingleThreaded | 1          | 5.464925461873450 | 5.17             | 60.3          |
| 10        | 50             | 1000        | SingleThreaded | 2          | 5.464925461873450 | 5.17             | 88.3          |
| 10        | 50             | 1000        | SingleThreaded | 3          | 5.464925461873450 | 5.17             | 110.9         |
| 10        | 50             | 1000        | SingleThreaded | 4          | 5.464925461873450 | 5.17             | 131.0         |
| 10        | 50             | 1000        | SingleThreaded | 5          | 5.464925461873450 | 5.17             | 146.3         |
| 10        | 50             | 1000        | MasterSlave    | 0          | 0.0               | 0.0              | 45.0          |
| 10        | 50             | 1000        | MasterSlave    | 1          | 5.464925461873450 | 5.17             | 69.3          |
| 10        | 50             | 1000        | MasterSlave    | 2          | 5.464925461873450 | 5.17             | 74.9          |
| 10        | 50             | 1000        | MasterSlave    | 3          | 5.464925461873450 | 5.17             | 82.0          |
| 10        | 50             | 1000        | MasterSlave    | 4          | 5.464925461873450 | 5.17             | 86.2          |
| 10        | 50             | 1000        | MasterSlave    | 5          | 5.464925461873450 | 5.17             | 92.5          |
| 10        | 50             | 1000        | Islands(2)     | 0          | 0.0               | 0.0              | 136.9         |
| 10        | 50             | 1000        | Islands(2)     | 1          | 9.542016564770270 | 8.91             | 103.7         |
| 10        | 50             | 1000        | Islands(2)     | 2          | 8.970651491180810 | 8.72             | 120.8         |
| 10        | 50             | 1000        | Islands(2)     | 3          | 9.302230858084640 | 8.91             | 126.8         |
| 10        | 50             | 1000        | Islands(2)     | 4          | 9.117263374695560 | 8.74             | 146.6         |
| 10        | 50             | 1000        | Islands(2)     | 5          | 9.564667479922360 | 8.83             | 164.4         |
| 10        | 50             | 1000        | Islands(8)     | 0          | 0.0               | 0.0              | 1086.8        |
| 10        | 50             | 1000        | Islands(8)     | 1          | 9.63645312744944  | 9.1              | 1185.1        |
| 10        | 50             | 1000        | Islands(8)     | 2          | 9.472175221824320 | 9.08             | 1095.5        |
| 10        | 50             | 1000        | Islands(8)     | 3          | 9.551569573522430 | 9.14             | 1122.0        |
| 10        | 50             | 1000        | Islands(8)     | 4          | 9.315990878318860 | 8.98             | 1140.1        |
| 10        | 50             | 1000        | Islands(8)     | 5          | 9.677130813969870 | 9.14             | 1089.1        |

График зависимости времени от количества поколений:

![by_generations](https://github.com/Punctuality/Evolutionary_Algorithm_ITMO_2023/blob/main/Lab_6/images/by_generations.png?raw=true)

График зависимости времени от сложности подсчета фитнес-функции:

![by_complexity](https://github.com/Punctuality/Evolutionary_Algorithm_ITMO_2023/blob/main/Lab_6/images/by_complexity.png?raw=true)

И тот же самый график, но без Islands(8), чтобы лучше было видно характер зависимости остальных:

![by_complexity_filtered](https://github.com/Punctuality/Evolutionary_Algorithm_ITMO_2023/blob/main/Lab_6/images/by_complexity_filtered.png?raw=true)


### Ответы на вопросы

1. Какая модель алгоритма лучше при каких условиях?

Стоит заметить что из-за того что JVM потоки являются 1:1 потоками ОС, то их создание и управление ими - приводит к большому оверхэду с точки зрения CPU. Поэтому при маленьких сложностях проблемы или при маленьком количестве поколений, лучше использовать SingleThreaded, так как в этом случае, мы не будем тратить время на создание и переключение между потоками. Однако, при большой сложности фитнес-функции, лучше использовать MasterSlave. Стоит заметить что Islands во всех экспериментах показали себя хуже с точки зрения производительности, однако я предпологаю что это просто из-за специфики их реализации в данном фреймворке (как минимум на каждый `.evolve` создается отдельный пул потоков).

2. Как повлияет увеличение размерности проблемы на алгоритмы?

При увеличении размерности проблемы, время работы алгоритма в однопоточном приложении будет расти. Однако на мое удивление, при использовании многопоточных алгоритмов, время работы алгоритма только немного уменьшалось.

3. Как повлияет увеличение размера популяции на алгоритмы?

Во всех случиях, время работы алгоритма увеличивается линейной в зависимости от размера популяции.

4. Есть ли ограничение для количества островов?

Ограничением на количество островов является размер популяции, так как на острове, мы наверняка не хотим чтобы не было ни одного кандидата (хотя конечно так можно сделать, в случае когда различные острова имеют разный характер мутации и кроссовера). Однако, стоит заметить что в случае если количество острово будет превышать количество физических ядер процессора/процессоров, то это не даст никакого прироста в производительности, так как некоторые острова будут работать в одном потоке исполнения, что наоборот только замедлит общую работу алгоритма. Хотя такое количество островов может быть полезно в случае если какая либо стадия работы алгоритма использует блокирующие операции, например запрос к БД для подсчета фитнесс-функции, тогда чтобы поток не находился в состояния ожидания, можно допустить больше чем один остров на одно физическое ядро.

